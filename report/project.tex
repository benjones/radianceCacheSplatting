\documentclass[10pt,twopage]{acmsiggraph}

\usepackage{fancyheadings} % we need page numbers...
\usepackage{times}
\usepackage{graphicx}
\usepackage{hyperref}

% allow for many figures and tables on one page
\renewcommand{\topfraction}{1.0} % all floats ok
\setcounter{totalnumber}{10}     % #floats = 10
\renewcommand{\textfraction}{0.0} % no text ok
\renewcommand{\dbltopfraction}{0.4}


% override page numbering conventions of the acm style
\pagestyle{fancyplain}
\lhead[\name]{}		% author name on the left for even pages
\rhead[]{\name}		% and on the right for odd pages
\setcounter{page}{1}	% I need to change this line for the proceedings
 


%%%%%%%%%%%
%
% Do not change anything above this line!!!
%
%%%%%%%%%%%




\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Title and author(s)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Term Project for CPSC514 -- Irradiance Cache Splatting}

\newcommand\name{Ben Jones}

\author{\name\\
\\
Department of Computer Science\\
The University of British Columbia}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Abstract
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
  This document describes the procedure for projects in CPSC 514. The
  document also serves as an example for simple \LaTeX\ documents.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Introduction
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{Intro}

Fast, realistic rendering of complex scenes is one of the major goals of computer graphics.  Methods based on Monte-Carlo ray tracing provide photorealistic results but are far too slow to be used in interactive applications \cite{raytracing}.  One of the problems associated with these techniques is that they rely on complex data structures, meaning that they cannot easily take advantage of today's extremely powerful GPUs.  The algorithm presented in \cite{mainpaper} seeks to approximate the global illumination solution using operations that are well suited to running on a GPU.  For my course project, I implemented part of their "irradiance cache splatting" algorithm for diffuse scenes.

The algorithm adapts a technique from \cite{cook} which samples the indirect lighting at points interpolates between them to generate an approximation of total indirect contribution.  This result is combined with the direct illumination component to create the final image.  In the original algorithm, the interpolation is performed via nearest-neighbor queries, which is not an acceptable approach when using a GPU.  In the improved algorithm from \cite{mainpaper}, both the sampling and interpolation leverage the GPU's parallel processing ability.  The sampled values are computed by rendering the environment from points in the scene and performing a weighted summation of the pixel values.  The interpolation is performed by treating each sample as a sphere with radius proportional to its estimated error and "splatting" all the spheres onto a buffer.  The samples can be processed separately and no information about neighbors is required.

The rest of the paper describes the algorithm in more detail, my implementation, and my results.

\section{Algorithm}
The algorithm consists of 5 main steps.  
\begin{enumerate}
\item Irradiance records are computed for points in the scene, chosen at random in my implementation.  
\item The records are splatted into a buffer recording the indirect lighting contribution.  
\item The buffer is examined, and new samples are generated and splatted.  
\item The direct illumination component is computed.  
\item The indirect and direct contributions are combined to generate the final image.  
\end{enumerate}

Step 1 and 3 are computed using both the GPU and CPU.  Steps 2, 4 and 5 are performed using only the GPU.

\subsection{Record Computation}
Each record is generated by rendering the scene at a point visible from the viewpoint, in the direction of its normal.  The scene is rendered from the eye, and the positions, normals, and surface properties of all visible points in the scene is stored on the CPU so viewing transform can be set up quickly.  The rendering is performed using shadow mapping so the first-bounce visible light measured at each sample is accurate.  The image is then copied to the CPU where a summation is performed as in \cite{lco4}: 
$$
E = \sum_{x,y}\frac{p(x,y)\Delta A_f}{\pi(x^2 + y^2 +1)^2}
$$
where E is the computed irradiance, $p(x,y)$ is the pixel value at $(x,y)$,  and $\Delta A_f$ is the area of each pixel.  While this calculation can be performed on the GPU using mipmap generation, \cite{mainpaper} performed it on the CPU, so my implementation does as well.  The irradiance for each color channel (r,g,b) is computed separately.

Another aggregate quantity, the harmonic mean distance to objects, is computed at each sample by summation of the depth values of visible objects.  This computation is also performed on the CPU.

Ideally, the entire hemisphere around the record point would be sampled, but sampling a plane is much easier and faster to do using the GPU's rasterization engine.  In order to minimize error, a very wide field of view angle, and very short front clipping plane distance are used.    

\subsection{Record Splatting}
Each sample as compute in step 1 is projected onto the image plane as a sphere, representing which visible pixels have similar indirect contribution.  The spheres have radius = $aR_k$ where $a$ is a tunable parameter, and $R_k$ is the harmonic mean distance to objects visible at sample $k$.

For each pixel in the buffer in the bounding box of the sphere associated with record $k$, a weight, $w$ is computed as
$$
w_k = \frac{1}{\frac{p - p_k}{R_k} + \sqrt{1 - n \cdot n_k}}
$$
where p is the position of the point, $p_k$ is the position of the associated sample, $n$ and $n_k$ are the normals of the point and associated sample, respectively.

For each pixel, if this value is greater than the $1/a$ tolerance, the associated irradiance is added to the buffer: 
$$
buf(x,y).L_0 += wL_0
buf.w += w
$$
where $L_0$ is the estimated irradiance at $(x,y)$.  \cite{mainpaper} computes $L_0$ taking the gradiants of the sample into account, but in my implementation, $L_0 = E_k*\rho_d$, the sampled irradiance value multiplied by the diffuse reflectance of the surface.  

\subsection{Buffer Examination}
The splatting for all samples is performed simultaneously on the GPU, however, especially for the first frame, the scene many be sampled adequately.  To remedy this, the splat buffer is read onto the CPU, and each pixel is examined.  If its weight is less than $a$, a new sample is generated at that point.  Still on the CPU, the weight is splatted onto the CPU copy of the buffer so that nearby pixels have their weights updated, and fewer samples will be generated.  After traversing the buffer, the newly generated samples are splatted onto the CPU copy of the buffer.

\subsection{Direct Illumination}
The direction illumination component is computed by rendering the scene from the viewpoint with shadow mapping.  Antialiasing is performed to prevent jagged edges on shadow boundaries.

\subsection{Combining Direct and Indirect Components}
In my implementation, the direct and indirect contributions were combined with a simple weighted sum.  This turned out not to be an adequate approach, and the weighting results in a tradeoff between the subtle details of color bleeding and washing out the shading of the rest of the scene.

\bibliographystyle{acmsiggraph}
{\small\bibliography{bibliography}}

%%%%%%%%%%%
%
% Do not change anything below this line!!!
%
%%%%%%%%%%%


% adds an empty page to documents with odd page number. This is to
% make sure that the first page of every paper starts at an odd page.
\cleardoublepage

\end{document}

% LocalWords:  CPSC Heidrich PDF cpsc tex dvi xdvi BibTeX bibtex PostScript ps
% LocalWords:  dvips Ppdf pdf pdflatex EPS PNG includegraphics
